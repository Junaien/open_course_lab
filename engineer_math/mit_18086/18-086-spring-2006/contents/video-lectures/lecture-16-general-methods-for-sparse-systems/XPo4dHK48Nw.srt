1
00:00:00,000 --> 00:00:01,950
The following
content is provided

2
00:00:01,950 --> 00:00:06,120
by MIT OpenCourseWare under
a Creative Commons license.

3
00:00:06,120 --> 00:00:08,230
Additional information
about our license

4
00:00:08,230 --> 00:00:10,490
and MIT OpenCourseWare
in general

5
00:00:10,490 --> 00:00:11,930
is available at ocw.mit.edu.

6
00:00:16,620 --> 00:00:18,120
PROFESSOR: This
morning's SIAM News.

7
00:00:20,820 --> 00:00:22,460
Well, it's an
article on something

8
00:00:22,460 --> 00:00:26,210
that's not totally up to date
because it's a method that

9
00:00:26,210 --> 00:00:30,140
was developed 50 years ago
called alternating direction

10
00:00:30,140 --> 00:00:32,950
and it was exactly
developed-- first

11
00:00:32,950 --> 00:00:39,330
you did an iteration
in the x direction.

12
00:00:39,330 --> 00:00:42,610
Of course, we're
tridiagonal along every row,

13
00:00:42,610 --> 00:00:44,460
we're one-dimensional.

14
00:00:44,460 --> 00:00:49,810
And then the second
half-step is an iteration

15
00:00:49,810 --> 00:00:51,040
in the y direction.

16
00:00:51,040 --> 00:00:54,360
Again, tridiagonal, so
the iteration's very fast.

17
00:00:54,360 --> 00:00:58,200
You flip-- alternating direction
describes it perfectly.

18
00:00:58,200 --> 00:01:00,210
And that method is still used.

19
00:01:00,210 --> 00:01:05,450
It got developed in the oil
reservoir simulation world.

20
00:01:05,450 --> 00:01:07,410
That is, Houston.

21
00:01:07,410 --> 00:01:12,740
And the article
says the evolution

22
00:01:12,740 --> 00:01:18,190
of techniques for oil reservoir
simulation has continued.

23
00:01:18,190 --> 00:01:24,210
And then mentions 3-- so it went
from this alternating direction

24
00:01:24,210 --> 00:01:32,430
to line overrelaxation,
LSOR, overrelaxation,

25
00:01:32,430 --> 00:01:36,250
and I only spoke
briefly about that.

26
00:01:36,250 --> 00:01:37,600
What's that word line mean?

27
00:01:37,600 --> 00:01:42,160
That means that we're
taking whole rows at once,

28
00:01:42,160 --> 00:01:43,520
working with blocks.

29
00:01:43,520 --> 00:01:48,130
And I'll add some
notes about that today.

30
00:01:48,130 --> 00:01:52,160
So that was the
next step, line SOR.

31
00:01:52,160 --> 00:01:56,770
Then to the Newton-Krylov
schemes, that's what's coming,

32
00:01:56,770 --> 00:02:03,440
Krylov, Conjugate gradients,
with ILU type preconditioners.

33
00:02:03,440 --> 00:02:06,390
So again, we're talking
about preconditioners

34
00:02:06,390 --> 00:02:13,120
and one important choice
is this incomplete LU.

35
00:02:13,120 --> 00:02:19,970
So notes on Gauss-Seidel and I
should maybe add incomplete LU.

36
00:02:19,970 --> 00:02:24,330
By the way, experiments
badly needed here too.

37
00:02:24,330 --> 00:02:32,090
Because incomplete LU has
this tolerance and as you

38
00:02:32,090 --> 00:02:37,470
move the tolerance you
get closer or far away

39
00:02:37,470 --> 00:02:43,530
to the exact L and U, but
you get faster or slower.

40
00:02:43,530 --> 00:02:45,580
So what's the balance?

41
00:02:45,580 --> 00:02:47,920
What's the right tolerance?

42
00:02:47,920 --> 00:02:51,620
How do these methods
compare-- and overall,

43
00:02:51,620 --> 00:02:55,260
how do these iterative methods
that we're speaking about

44
00:02:55,260 --> 00:02:58,390
compare with these
direct methods?

45
00:02:58,390 --> 00:03:04,670
So we really are in this new
chapter, solving large systems,

46
00:03:04,670 --> 00:03:10,080
facing a whole lot of
possible new experiments.

47
00:03:10,080 --> 00:03:14,940
So just to continue the history
or the future as described

48
00:03:14,940 --> 00:03:19,230
in SIAM News, so there was
alternating direction, line

49
00:03:19,230 --> 00:03:20,460
SOR.

50
00:03:20,460 --> 00:03:28,700
Then to Krylov schemes with ILU
preconditioners in use today.

51
00:03:28,700 --> 00:03:31,120
So this is a big use area.

52
00:03:31,120 --> 00:03:38,170
And the multiscale, multigrid
solvers that are quote,

53
00:03:38,170 --> 00:03:41,140
now starting to come of age.

54
00:03:41,140 --> 00:03:47,180
So that's a third topic for
today's lecture, multigrid.

55
00:03:47,180 --> 00:03:52,300
That-- of course, it's
been around for some time,

56
00:03:52,300 --> 00:03:56,730
but it involved,
especially at the start,

57
00:03:56,730 --> 00:04:01,420
more effort in programming.

58
00:04:04,040 --> 00:04:09,460
So it didn't quickly-- I
mean, it gave great results

59
00:04:09,460 --> 00:04:12,970
on model problems.

60
00:04:12,970 --> 00:04:15,290
On other problems,
too, but still

61
00:04:15,290 --> 00:04:19,790
it kind of hasn't yet,
but is penetrating

62
00:04:19,790 --> 00:04:23,430
into production code,
where the oil reservoir

63
00:04:23,430 --> 00:04:26,420
industry or other big
industries would use it.

64
00:04:26,420 --> 00:04:33,520
So here you see, really, a
pretty fair picture of where we

65
00:04:33,520 --> 00:04:36,800
are today with large solvers.

66
00:04:36,800 --> 00:04:39,760
These are very important.

67
00:04:39,760 --> 00:04:44,830
Minimum degree-- if the
size is not overwhelming,

68
00:04:44,830 --> 00:04:48,700
direct methods are going
to be right up there.

69
00:04:48,700 --> 00:04:53,850
And these are the
pure iterations,

70
00:04:53,850 --> 00:05:01,050
stationary iterations that, with
this idea, this incomplete LU

71
00:05:01,050 --> 00:05:04,620
idea, get pretty good.

72
00:05:04,620 --> 00:05:07,410
But the formula's
always simple there.

73
00:05:07,410 --> 00:05:13,730
The new x comes from the old
x by the same iterations.

74
00:05:13,730 --> 00:05:18,450
Whereas, if we use
the ideas there as

75
00:05:18,450 --> 00:05:25,060
preconditioners and look
to see-- so the point was,

76
00:05:25,060 --> 00:05:28,840
and I'll repeat it again,
that Gauss-Seidel and Jacobi,

77
00:05:28,840 --> 00:05:32,760
the standard iterations,
were quite satisfactory

78
00:05:32,760 --> 00:05:34,810
on high frequencies.

79
00:05:34,810 --> 00:05:37,960
They damped those out
quite well in the error,

80
00:05:37,960 --> 00:05:42,290
but they don't tackle the low
frequency, the smooth part

81
00:05:42,290 --> 00:05:44,560
of the error, very efficiently.

82
00:05:44,560 --> 00:05:49,470
And that's what multigrid
does incredibly well, so it's

83
00:05:49,470 --> 00:05:51,890
a nice mixture of the two.

84
00:05:51,890 --> 00:05:55,300
These are the smoothers,
this is the change

85
00:05:55,300 --> 00:06:00,170
of scale, change of grid that's
coming now and will come.

86
00:06:00,170 --> 00:06:06,190
So all this will be my subject
for this week and next,

87
00:06:06,190 --> 00:06:07,350
prior to spring break.

88
00:06:07,350 --> 00:06:13,390
And I think you will have enough
to go on to do experiments.

89
00:06:13,390 --> 00:06:15,570
It could be highly interesting.

90
00:06:15,570 --> 00:06:20,810
OK, so that's the
SIAM News report.

91
00:06:20,810 --> 00:06:26,910
OK, what do I want to
say about minimum degree?

92
00:06:26,910 --> 00:06:29,440
And more will go on the web.

93
00:06:29,440 --> 00:06:37,100
Just a few more notes about what
we did on Monday after class.

94
00:06:37,100 --> 00:06:43,710
If you take a matrix like
that, you take a matrix

95
00:06:43,710 --> 00:06:47,940
and-- how is it described
in sparse format?

96
00:06:47,940 --> 00:06:52,290
Sparse format you can
see-- normally you

97
00:06:52,290 --> 00:06:54,490
don't have to see
it, it's usually

98
00:06:54,490 --> 00:06:58,230
inside the sparse
MATLAB, but if you

99
00:06:58,230 --> 00:07:03,970
want to see what's happening,
you could ask for i, j, and s.

100
00:07:03,970 --> 00:07:05,930
Now what are those?

101
00:07:05,930 --> 00:07:10,660
What will that
produce? i will be

102
00:07:10,660 --> 00:07:14,140
the list of nonzeros,
the list of the row

103
00:07:14,140 --> 00:07:16,420
numbers of the nonzeros.

104
00:07:16,420 --> 00:07:23,060
So i will be-- maybe I'll write
it as a row so I'm transposing,

105
00:07:23,060 --> 00:07:28,820
So the row numbers would
be row 1, row 2, not row 3.

106
00:07:28,820 --> 00:07:32,270
Row 1, 2, 3, row 2, 3.

107
00:07:35,320 --> 00:07:39,890
The column numbers
would be-- these

108
00:07:39,890 --> 00:07:42,040
are going to be
the pairs (i, j).

109
00:07:42,040 --> 00:07:48,010
So that's column 1 twice,
column 2 three times.

110
00:07:48,010 --> 00:07:49,070
Column 3 twice.

111
00:07:52,520 --> 00:07:58,440
And what's s? s is the actual
numbers in position (i, j),

112
00:07:58,440 --> 00:08:00,340
is the number 2.

113
00:08:00,340 --> 00:08:04,240
In position (2, 1) is
the number minus 1.

114
00:08:04,240 --> 00:08:08,720
So those numbers, minus 1,
2, minus 1 is that column.

115
00:08:08,720 --> 00:08:12,810
And then minus 1,
2 is that column.

116
00:08:12,810 --> 00:08:16,290
So of course, we've got all
the information in the matrix.

117
00:08:16,290 --> 00:08:23,190
We know every nonzero position
and we know what that entry is.

118
00:08:23,190 --> 00:08:27,180
And of course, our matrices
are much bigger than this one,

119
00:08:27,180 --> 00:08:35,370
but already we can see
one useful point-- point

120
00:08:35,370 --> 00:08:41,170
being that key word-- that the
column numbers, this-- I mean,

121
00:08:41,170 --> 00:08:45,940
imagine we have a large
matrix, so this j is not

122
00:08:45,940 --> 00:08:52,610
very efficiently recorded
here because what's j?

123
00:08:52,610 --> 00:08:55,600
We're looking at nonzeros
a column at a time,

124
00:08:55,600 --> 00:09:00,090
so of course, we'll have a few
ones for the nonzeros in column

125
00:09:00,090 --> 00:09:07,340
1 and then some twos and then
some threes and some fours,

126
00:09:07,340 --> 00:09:14,650
but all this row is-- the
real information in that row

127
00:09:14,650 --> 00:09:20,290
is a pointer to--
in other words,

128
00:09:20,290 --> 00:09:24,330
I don't have to
repeat 2 three times.

129
00:09:24,330 --> 00:09:30,780
So really, if I put inside
here a compressed version

130
00:09:30,780 --> 00:09:36,720
of j, a pointer, would be a
short factor that just has a 1.

131
00:09:36,720 --> 00:09:42,860
It says look in position 1
for the start of column 1.

132
00:09:42,860 --> 00:09:48,610
Then a 3-- see, I didn't
need that because that just

133
00:09:48,610 --> 00:09:49,830
continued column 1.

134
00:09:49,830 --> 00:09:52,660
That just repeated
the j I already had.

135
00:09:52,660 --> 00:09:57,700
But this tells me that
in the third position

136
00:09:57,700 --> 00:09:59,850
I start down column 2.

137
00:09:59,850 --> 00:10:04,230
And this would tell me that
in position number 4, 5, 6,

138
00:10:04,230 --> 00:10:09,540
I guess, I start down column 3.

139
00:10:09,540 --> 00:10:11,030
You see the point of that 6.

140
00:10:11,030 --> 00:10:15,670
That 6 picks out--
yes-- 1, 2, 3, 4, 5,

141
00:10:15,670 --> 00:10:20,400
the sixth row number
is the beginning

142
00:10:20,400 --> 00:10:22,670
of information on column 3.

143
00:10:22,670 --> 00:10:25,110
And then it's
conventional to have

144
00:10:25,110 --> 00:10:31,010
a pointer, 8, to say finish.

145
00:10:31,010 --> 00:10:36,100
So that's pointing
to empty space.

146
00:10:36,100 --> 00:10:40,080
So in other words, j got
compressed to 1, 3, 6, 8

147
00:10:40,080 --> 00:10:44,690
and in a large problem it
would get seriously compressed.

148
00:10:44,690 --> 00:10:54,800
OK, so that's the form in
which the code keeps the matrix

149
00:10:54,800 --> 00:11:00,490
and does the reorderings.

150
00:11:00,490 --> 00:11:05,190
Let me just mention that
the opposite of this

151
00:11:05,190 --> 00:11:09,630
would create the matrix
out of these i, j, s.

152
00:11:09,630 --> 00:11:12,870
What command would that be?

153
00:11:12,870 --> 00:11:18,450
You could create the matrix
A out of-- the command sparse

154
00:11:18,450 --> 00:11:19,960
would be good.

155
00:11:19,960 --> 00:11:25,110
Sparse of the inputs,
now, would be i, j, s.

156
00:11:25,110 --> 00:11:31,670
If I input i, j, and s then
that lab creates a matrix.

157
00:11:31,670 --> 00:11:33,900
And sometimes I
may want to include

158
00:11:33,900 --> 00:11:41,970
the m and n, the shape of the
matrix, as further parameters,

159
00:11:41,970 --> 00:11:45,340
but actually here
I wouldn't have to.

160
00:11:45,340 --> 00:11:48,970
So this is the opposite
command from this one

161
00:11:48,970 --> 00:11:52,920
that we're interested in.

162
00:11:52,920 --> 00:11:53,770
You can imagine.

163
00:11:53,770 --> 00:12:04,250
Suppose by using minimum
degree or some other decision,

164
00:12:04,250 --> 00:12:07,010
I've eliminated up
to a certain point

165
00:12:07,010 --> 00:12:11,420
and I want to put the remaining
columns in a different order.

166
00:12:11,420 --> 00:12:15,950
I can do that just by
playing with the pointers.

167
00:12:15,950 --> 00:12:21,130
So it's a very efficient
structure for sparse matrices.

168
00:12:27,690 --> 00:12:31,110
And then comes the question,
OK, what's the good order?

169
00:12:34,270 --> 00:12:39,150
I was surprised to realize
how open a problem that

170
00:12:39,150 --> 00:12:47,720
still is, even from the expert
who's developing the key code.

171
00:12:52,470 --> 00:12:56,340
So approximate minimum degree,
of course, by that word

172
00:12:56,340 --> 00:13:00,370
you see that it allows freedom.

173
00:13:00,370 --> 00:13:02,140
There are also
decisions to be made

174
00:13:02,140 --> 00:13:06,340
when minimum degree is a
tie between several nodes,

175
00:13:06,340 --> 00:13:08,080
as it commonly is.

176
00:13:08,080 --> 00:13:12,430
And it's rather nice to
get a MATLAB movie that

177
00:13:12,430 --> 00:13:18,260
shows the order
in which nodes are

178
00:13:18,260 --> 00:13:24,670
eliminated, edges are removed
from the graph, from the mesh.

179
00:13:24,670 --> 00:13:27,040
You'll see that.

180
00:13:27,040 --> 00:13:30,900
All right, I'm ready to go
ahead now to some comment

181
00:13:30,900 --> 00:13:32,190
on Gauss-Seidel.

182
00:13:32,190 --> 00:13:35,110
Maybe I'll put that here.

183
00:13:35,110 --> 00:13:37,780
In fact, maybe I'll just
take the same matrix.

184
00:13:37,780 --> 00:13:43,880
So now I want to remember,
what is the Gauss-Seidel method

185
00:13:43,880 --> 00:13:45,830
for A*x equal b.

186
00:13:45,830 --> 00:13:47,430
What's the iteration now?

187
00:13:47,430 --> 00:13:52,230
And again, A will be the same:
2, minus 1, zero; minus 1,

188
00:13:52,230 --> 00:13:53,890
2, minus 1.

189
00:13:53,890 --> 00:13:57,620
My favorite, OK.

190
00:13:57,620 --> 00:14:00,850
So all these iterations,
you remember,

191
00:14:00,850 --> 00:14:04,720
are splittings of the matrix.

192
00:14:04,720 --> 00:14:07,470
Some of the matrix goes
on the left-hand side.

193
00:14:07,470 --> 00:14:09,700
That's the preconditioner.

194
00:14:09,700 --> 00:14:11,940
So it's P, the
preconditioner that's

195
00:14:11,940 --> 00:14:16,970
sort of close to A in some
sense, but easy to work with,

196
00:14:16,970 --> 00:14:21,550
multiplies the new thing
and on the other side

197
00:14:21,550 --> 00:14:25,890
is A minus A-- the rest
of the matrix-- that

198
00:14:25,890 --> 00:14:31,900
multiplies the old plus
the right-hand side b.

199
00:14:31,900 --> 00:14:36,750
Let's just remember again, that
if we converge to the point

200
00:14:36,750 --> 00:14:42,300
where this is the same as this,
then we have the right answer.

201
00:14:42,300 --> 00:14:45,510
We have the right answer because
if that's the same as that,

202
00:14:45,510 --> 00:14:49,780
P*x is the same as P*x, this
comes over on the other side,

203
00:14:49,780 --> 00:14:51,830
A*x equals b.

204
00:14:51,830 --> 00:14:56,870
So when it converges, it
converges to the right answer,

205
00:14:56,870 --> 00:14:59,300
but you remember that
the key equation was

206
00:14:59,300 --> 00:15:06,920
that the new error is
the old error multiplied

207
00:15:06,920 --> 00:15:14,240
by this matrix I minus P inverse
A. That's the iteration matrix,

208
00:15:14,240 --> 00:15:17,190
you could say.

209
00:15:17,190 --> 00:15:21,400
I just get it when I multiply
both sides by P inverse.

210
00:15:21,400 --> 00:15:30,240
And so the problem is choose
P so that this is easy to do

211
00:15:30,240 --> 00:15:34,310
and at the same time,
this has small eigenvalues

212
00:15:34,310 --> 00:15:35,820
or as small as you can get.

213
00:15:35,820 --> 00:15:38,810
So the Gauss-Seidel is
a particular choice,

214
00:15:38,810 --> 00:15:43,430
which takes the lower-- P is
the lower triangular part here.

215
00:15:43,430 --> 00:15:48,030
So P is, so I just thought I'd
better write down, explicitly:

216
00:15:48,030 --> 00:15:55,020
Gauss-Seidel takes
that, with zeros there,

217
00:15:55,020 --> 00:16:00,200
as multiplying-- that's
P. And what's P minus A?

218
00:16:00,200 --> 00:16:02,730
It's the rest.

219
00:16:02,730 --> 00:16:05,640
And it's been moved
to the other side

220
00:16:05,640 --> 00:16:10,740
so the rest is going to be the
strictly upper triangular part.

221
00:16:10,740 --> 00:16:12,840
And because it's moved
over to the other side

222
00:16:12,840 --> 00:16:14,430
it'll have a plus sign.

223
00:16:14,430 --> 00:16:15,750
It'll be 1 and 1.

224
00:16:20,600 --> 00:16:24,740
x_k plus b.

225
00:16:24,740 --> 00:16:31,810
I just write it out so that
you see, totally explicitly,

226
00:16:31,810 --> 00:16:41,420
how being triangular makes
the solution step immediate.

227
00:16:41,420 --> 00:16:45,060
Because the first equation will
tell us the first component,

228
00:16:45,060 --> 00:16:46,680
right?

229
00:16:46,680 --> 00:16:49,340
The first equation,
because it's triangular

230
00:16:49,340 --> 00:16:51,150
there's only an entry here.

231
00:16:51,150 --> 00:16:57,860
And by the way, all these
codes, including Tim Davis's

232
00:16:57,860 --> 00:17:00,870
minimum degree codes,
their very first step

233
00:17:00,870 --> 00:17:05,100
is reorder the
equations if necessary

234
00:17:05,100 --> 00:17:09,870
to guarantee that the main
diagonal has no zeros.

235
00:17:09,870 --> 00:17:13,250
We want to know that in advance.

236
00:17:13,250 --> 00:17:16,320
So that you just
do, let's assume it.

237
00:17:16,320 --> 00:17:18,690
Of course, for us it
happens automatically.

238
00:17:18,690 --> 00:17:21,320
OK, so that's not zero.

239
00:17:21,320 --> 00:17:24,580
And that first equation
gives us the first component,

240
00:17:24,580 --> 00:17:28,690
then we know the first
component so we use it here,

241
00:17:28,690 --> 00:17:32,470
and the second equation tells
us what the second component is.

242
00:17:32,470 --> 00:17:35,940
We use that second component
in the third equation

243
00:17:35,940 --> 00:17:40,590
to find the third component.

244
00:17:40,590 --> 00:17:45,700
So there's no loss of
speed compared to diagonal

245
00:17:45,700 --> 00:17:50,030
and actually, it's faster
because the storage--

246
00:17:50,030 --> 00:17:55,210
we're changing-- we're using
the new first component to find

247
00:17:55,210 --> 00:17:59,000
the second and the new second
component to find the third,

248
00:17:59,000 --> 00:18:04,920
so we can overwrite
x_k by x_(k+1).

249
00:18:08,330 --> 00:18:08,900
Let's see.

250
00:18:08,900 --> 00:18:13,490
I guess if I had space and had
prepared I would figure out

251
00:18:13,490 --> 00:18:16,700
what this matrix is.

252
00:18:16,700 --> 00:18:19,000
Maybe you could do that.

253
00:18:19,000 --> 00:18:23,080
Figure out what-- here's
P. It's invertible.

254
00:18:23,080 --> 00:18:26,170
P inverse is going
to be quite simple.

255
00:18:26,170 --> 00:18:30,080
Actually, it would
be extremely simple.

256
00:18:30,080 --> 00:18:32,800
You'll be able to see its
eigenvalues immediately.

257
00:18:35,590 --> 00:18:38,940
We could stop to do it,
but I think if you do it,

258
00:18:38,940 --> 00:18:41,960
it's more valuable.

259
00:18:41,960 --> 00:18:45,510
So we would find that its
eigenvalues were below 1

260
00:18:45,510 --> 00:18:52,360
and that they were the squares
of the Jacobi eigenvalues,

261
00:18:52,360 --> 00:18:55,890
so the method is twice
as fast as Jacobi.

262
00:18:55,890 --> 00:19:02,180
But it has the same good feature
of damping the high frequencies

263
00:19:02,180 --> 00:19:07,420
and the same bad feature
of not very much damping

264
00:19:07,420 --> 00:19:12,080
the low, smooth
part of the error.

265
00:19:12,080 --> 00:19:16,180
Now we're ready for multigrid,
which is intended to solve it.

266
00:19:16,180 --> 00:19:28,570
So multigrid is going to be--
the point is, by changing grid,

267
00:19:28,570 --> 00:19:38,270
by changing from the fine
grid to a coarse grid,

268
00:19:38,270 --> 00:19:42,060
the smooth oscillation
doesn't look so smooth.

269
00:19:42,060 --> 00:19:48,620
On the coarse grid,
its effective frequency

270
00:19:48,620 --> 00:19:55,060
is effectively doubled and it's
moving over in the direction

271
00:19:55,060 --> 00:19:58,750
where the smoother
can attack it.

272
00:19:58,750 --> 00:20:01,100
We'll see that happen.

273
00:20:01,100 --> 00:20:04,450
So now, I have to, really--
this begins the lecture

274
00:20:04,450 --> 00:20:07,470
on multigrid, which
is going to take,

275
00:20:07,470 --> 00:20:09,270
certainly, today and Friday.

276
00:20:12,700 --> 00:20:17,010
There's a very good book
by Briggs and others.

277
00:20:24,110 --> 00:20:29,910
He wrote the first
edition of the book

278
00:20:29,910 --> 00:20:33,470
and coauthored the second one.

279
00:20:33,470 --> 00:20:36,560
And it's beautifully
short and clear and simple

280
00:20:36,560 --> 00:20:45,750
and this presentation will
follow the same exposition

281
00:20:45,750 --> 00:20:47,282
that the book does.

282
00:20:51,400 --> 00:21:00,380
So the key idea is
to see what-- how

283
00:21:00,380 --> 00:21:03,260
to go from a fine
grid problem, so this

284
00:21:03,260 --> 00:21:07,670
is on the fine grid
with step size h.

285
00:21:07,670 --> 00:21:09,810
So this A_h is our problem.

286
00:21:09,810 --> 00:21:16,490
A_h is A. A_h, b
sub h, we're looking

287
00:21:16,490 --> 00:21:20,430
for u_h on the fine grid.

288
00:21:20,430 --> 00:21:24,040
Fine grid means
lots of mesh points,

289
00:21:24,040 --> 00:21:26,840
lots of unknowns, big problem.

290
00:21:26,840 --> 00:21:30,760
OK, so the idea is
going to be, somehow,

291
00:21:30,760 --> 00:21:35,220
to-- let me just
start with two grids.

292
00:21:39,310 --> 00:21:46,820
Well, you can see what you do
on the fine grid at the start.

293
00:21:46,820 --> 00:21:47,700
You iterate.

294
00:21:47,700 --> 00:21:51,210
You use Gauss-Seidel
or Jacobi, whatever.

295
00:21:51,210 --> 00:21:52,940
Maybe three times.

296
00:21:52,940 --> 00:21:54,930
Maybe three
iterations, but don't

297
00:21:54,930 --> 00:21:56,650
continue to a
thousand iterations,

298
00:21:56,650 --> 00:21:59,450
it's a waste of time.

299
00:21:59,450 --> 00:22:03,530
Then, here is the real--
this is the multigrid part.

300
00:22:07,460 --> 00:22:09,580
The multigrid part
is going-- you

301
00:22:09,580 --> 00:22:14,070
get an answer after
a few iterations,

302
00:22:14,070 --> 00:22:16,040
after you've smoothed it.

303
00:22:16,040 --> 00:22:21,390
You compute this
residual, which is

304
00:22:21,390 --> 00:22:27,410
the amount you're wrong in
the equation, the difference

305
00:22:27,410 --> 00:22:32,950
between the right side
and the left side.

306
00:22:32,950 --> 00:22:35,710
I can put h's here
too, to emphasize.

307
00:22:35,710 --> 00:22:39,430
This is residuals being
computed with what we have,

308
00:22:39,430 --> 00:22:42,920
which is on the fine grid.

309
00:22:42,920 --> 00:22:45,620
Now here's the change of grid.

310
00:22:45,620 --> 00:22:50,160
Number two says, restrict
to a coarse grid.

311
00:22:50,160 --> 00:22:57,000
Take that r_h, that residual
which is probably a bit smooth,

312
00:22:57,000 --> 00:23:01,310
and move it to the coarse grid.

313
00:23:01,310 --> 00:23:05,490
So the coarse grid we
identify by the fact

314
00:23:05,490 --> 00:23:11,630
that its mesh width
is twice as big, 2h.

315
00:23:11,630 --> 00:23:14,730
And so we're going to
need some restriction,

316
00:23:14,730 --> 00:23:18,550
so the input to
this multigrid is

317
00:23:18,550 --> 00:23:24,880
to decide on a restriction
matrix, how shall we take

318
00:23:24,880 --> 00:23:27,800
values that are
given on a fine grid

319
00:23:27,800 --> 00:23:33,340
and restrict them
to a coarse grid?

320
00:23:33,340 --> 00:23:37,270
Of course, one restriction
is-- and it's not

321
00:23:37,270 --> 00:23:42,670
that bad-- is just to
take the values of r

322
00:23:42,670 --> 00:23:46,300
that are on the coarse grid
at every other grid point,

323
00:23:46,300 --> 00:23:48,910
use those.

324
00:23:48,910 --> 00:23:54,020
Or we could take into
account the neighbors.

325
00:23:54,020 --> 00:23:56,090
You see the question.

326
00:23:56,090 --> 00:24:00,130
So this is coming now
in this restriction.

327
00:24:00,130 --> 00:24:04,070
So the restriction
is, restriction R,

328
00:24:04,070 --> 00:24:11,110
this is fine to coarse,
and we have this question

329
00:24:11,110 --> 00:24:18,310
of use neighbors or not?

330
00:24:18,310 --> 00:24:21,760
That will enter.

331
00:24:21,760 --> 00:24:25,680
Well, the decision on
what the matrix R is.

332
00:24:25,680 --> 00:24:27,130
That's the key.

333
00:24:27,130 --> 00:24:30,840
OK, so we choose
an R, we restrict,

334
00:24:30,840 --> 00:24:33,630
and we have now a
half-size problem.

335
00:24:33,630 --> 00:24:37,570
Well, half-size in 1D,
quarter-size in 2D,

336
00:24:37,570 --> 00:24:44,130
eighth-size in 3D because
the mesh width has

337
00:24:44,130 --> 00:24:46,290
doubled in every coordinate.

338
00:24:48,880 --> 00:24:51,030
Now I've put solve.

339
00:24:51,030 --> 00:24:54,080
I better put quotes around that.

340
00:24:54,080 --> 00:24:58,500
Well, solve the problem
on the coarse mesh.

341
00:24:58,500 --> 00:25:02,420
So the idea is that
that's much faster.

342
00:25:02,420 --> 00:25:04,540
Well, you might
say, what problem?

343
00:25:04,540 --> 00:25:10,080
Well, we have to
create, somehow,

344
00:25:10,080 --> 00:25:12,730
the matrix on the coarse mesh.

345
00:25:12,730 --> 00:25:17,400
That's not necessarily
given to us.

346
00:25:17,400 --> 00:25:20,070
We start the
problem with A, A_h,

347
00:25:20,070 --> 00:25:23,030
the matrix on the fine grid.

348
00:25:23,030 --> 00:25:28,450
Can I just mention
that this is probably,

349
00:25:28,450 --> 00:25:33,740
this v-cycle-- that
letter v is supposed

350
00:25:33,740 --> 00:25:38,300
to suggest going down to
the coarse mesh and back up

351
00:25:38,300 --> 00:25:41,360
to the fine mesh.

352
00:25:41,360 --> 00:25:47,540
And the standard
notation in all the

353
00:25:47,540 --> 00:25:54,400
multigrid books is a capital
V. And why do I use a small v?

354
00:25:54,400 --> 00:26:00,010
This is my educational
contribution.

355
00:26:00,010 --> 00:26:06,410
Capital V is appropriate
when you have several meshes.

356
00:26:06,410 --> 00:26:11,560
You go to 2h, you go to 4h,
you go to 8h, back to 4h, back

357
00:26:11,560 --> 00:26:13,390
to 2h, back to h.

358
00:26:13,390 --> 00:26:16,130
So a deeper multigrid.

359
00:26:16,130 --> 00:26:19,250
So it would look
more complicated.

360
00:26:19,250 --> 00:26:24,370
I would repeat this idea
instead of solve here.

361
00:26:24,370 --> 00:26:27,420
Instead of solve at the 2h
level, which of course, I'm

362
00:26:27,420 --> 00:26:29,560
not going to do exactly anyway.

363
00:26:29,560 --> 00:26:36,530
But if I was in a
big V-cycle I would

364
00:26:36,530 --> 00:26:42,000
iterate a few times to smooth
here, just as I did here.

365
00:26:42,000 --> 00:26:47,620
I would iterate using
weighted Jacobi or something

366
00:26:47,620 --> 00:26:51,490
and then go down to the 4h mesh.

367
00:26:51,490 --> 00:26:53,540
So restrict to the 4h mesh.

368
00:26:53,540 --> 00:26:57,840
So you can see that I would
stay in this little loop

369
00:26:57,840 --> 00:27:03,570
to get to the bottom, 8h, and
then I would start back up.

370
00:27:03,570 --> 00:27:07,780
So I think it's a good
idea to use a small letter

371
00:27:07,780 --> 00:27:14,010
v to tell us-- rather than
saying two-grid capital

372
00:27:14,010 --> 00:27:19,000
V-cycle, I'm just going
to use a small v to signal

373
00:27:19,000 --> 00:27:21,870
right away that it's two grids.

374
00:27:21,870 --> 00:27:23,690
Fine, coarse, fine.

375
00:27:23,690 --> 00:27:31,330
OK, so we have some solution,
not necessarily exact

376
00:27:31,330 --> 00:27:34,550
and actually, there
isn't that much point

377
00:27:34,550 --> 00:27:39,450
in getting it exact
because what we want

378
00:27:39,450 --> 00:27:42,380
is to move toward
the right answer.

379
00:27:44,890 --> 00:27:48,440
And notice that I'm
looking here at the error,

380
00:27:48,440 --> 00:27:54,170
rather than looking at A_(2h),
u_(2h), the actual solution.

381
00:27:54,170 --> 00:27:58,180
What I'm computing with
is the correction term.

382
00:27:58,180 --> 00:28:03,150
So this is the correction
term that I find.

383
00:28:03,150 --> 00:28:07,650
So this is the
residual over here.

384
00:28:07,650 --> 00:28:11,220
this is the A_(2h) that
I still have to choose,

385
00:28:11,220 --> 00:28:15,740
and then solving that
will give me a correction,

386
00:28:15,740 --> 00:28:21,370
but that correction
is on coarse mesh.

387
00:28:21,370 --> 00:28:29,210
I've only had that correction
E_(2h) defined on the 2h mesh.

388
00:28:29,210 --> 00:28:35,000
So now comes the other
part of multigrid.

389
00:28:35,000 --> 00:28:40,210
Get back to the fine
mesh, climb back up.

390
00:28:40,210 --> 00:28:44,820
I take that E_(2h) and
apply an interpolation.

391
00:28:44,820 --> 00:28:49,210
I need to create
an interpolation.

392
00:28:49,210 --> 00:28:51,860
This is going to
be coarse to fine.

393
00:28:56,420 --> 00:29:00,560
And I have to decide
how to do that.

394
00:29:00,560 --> 00:29:05,280
Once I've decided
it that gives me

395
00:29:05,280 --> 00:29:08,170
a correction at the
fine mesh level, which

396
00:29:08,170 --> 00:29:13,470
is where I'm really working,
so I make the correction

397
00:29:13,470 --> 00:29:16,100
and I have a better answer.

398
00:29:16,100 --> 00:29:21,720
And probably, I
iterate a few times--

399
00:29:21,720 --> 00:29:25,590
that would be called
a post-smoother--

400
00:29:25,590 --> 00:29:26,510
on that correction.

401
00:29:26,510 --> 00:29:32,790
And maybe that's where I stop or
maybe I repeat little v-cycles,

402
00:29:32,790 --> 00:29:36,380
but that's not brilliant.

403
00:29:36,380 --> 00:29:40,930
If you're going to do
multiple-- if you're

404
00:29:40,930 --> 00:29:44,740
going to repeat multigrid,
it's much more efficient

405
00:29:44,740 --> 00:29:52,430
to move to more and
more coarse meshes

406
00:29:52,430 --> 00:29:56,710
because the
calculations on these

407
00:29:56,710 --> 00:30:02,310
are way faster than
on the fine mesh.

408
00:30:02,310 --> 00:30:07,370
You see, rather
than-- I much prefer

409
00:30:07,370 --> 00:30:10,770
to go way down and back
up than a lot of v-cycles.

410
00:30:10,770 --> 00:30:16,780
I mean, that would
be a small w-cycle.

411
00:30:16,780 --> 00:30:19,370
And not brilliant.

412
00:30:19,370 --> 00:30:25,610
Much better to use a big
V-cycle or a big W-cycle.

413
00:30:25,610 --> 00:30:28,830
There's a place for W-cycles,
but they're capital W-cycles,

414
00:30:28,830 --> 00:30:31,450
because you want
to get down where

415
00:30:31,450 --> 00:30:35,400
it is very fast, very
inexpensive and in fact,

416
00:30:35,400 --> 00:30:40,060
so efficient that
multigrid achieves

417
00:30:40,060 --> 00:30:48,940
this holy grail of giving you
an answer with whatever accuracy

418
00:30:48,940 --> 00:30:54,560
you want-- giving you an
answer in O of n operations.

419
00:30:54,560 --> 00:30:57,290
n being the matrix size.

420
00:30:57,290 --> 00:31:00,430
Capital N squared
in our example.

421
00:31:00,430 --> 00:31:07,340
So that's the fantastic
result from multigrid.

422
00:31:07,340 --> 00:31:17,450
So I'll come back to this,
but just say if the size of A

423
00:31:17,450 --> 00:31:22,770
is n, which is capital N in 1D,
capital N squared, capital N

424
00:31:22,770 --> 00:31:35,260
cubed, then the multigrid
works in O of n flops,

425
00:31:35,260 --> 00:31:36,390
floating points operations.

426
00:31:39,480 --> 00:31:44,985
Not even log n, which we
think of for the-- n log

427
00:31:44,985 --> 00:31:52,470
n we think of for the FFT, for
the Fast Fourier Transform.

428
00:31:52,470 --> 00:31:58,730
But here's it's
actually order of n.

429
00:31:58,730 --> 00:32:01,650
That really is a
goal worth achieving.

430
00:32:06,680 --> 00:32:09,870
So we know what the
smoothers might be.

431
00:32:09,870 --> 00:32:14,580
It's the I and the
R that are new.

432
00:32:14,580 --> 00:32:16,890
And then the analysis
of convergence,

433
00:32:16,890 --> 00:32:19,130
why does it converge?

434
00:32:19,130 --> 00:32:22,220
But to use the method,
and-- so by the way,

435
00:32:22,220 --> 00:32:25,030
projects using multigrid
are totally welcome also.

436
00:32:28,860 --> 00:32:33,720
So let me take the
interpolation I. So what's that?

437
00:32:33,720 --> 00:32:35,110
Coarse to fine.

438
00:32:35,110 --> 00:32:39,850
Let me imagine I'm in 1D,
so there's the x direction.

439
00:32:39,850 --> 00:32:42,650
Here's one end of the
interval, here's the other end

440
00:32:42,650 --> 00:32:45,380
of the interval and suppose my
boundary conditions are zero.

441
00:32:50,370 --> 00:32:58,630
So this is the coarse mesh
and let me put in here,

442
00:32:58,630 --> 00:33:02,670
make it the fine mesh.

443
00:33:02,670 --> 00:33:04,400
So at this point,
I have an answer

444
00:33:04,400 --> 00:33:08,150
on the coarse mesh, which
satisfies the boundary

445
00:33:08,150 --> 00:33:14,890
condition, and let's say
it's there, there, and there.

446
00:33:17,580 --> 00:33:23,170
OK, and I need values on the
fine mesh at the other points.

447
00:33:23,170 --> 00:33:26,730
Of course, I'm going
to use these values

448
00:33:26,730 --> 00:33:27,930
when I interpolate them.

449
00:33:27,930 --> 00:33:31,200
That word interpolation
means-- implies,

450
00:33:31,200 --> 00:33:34,440
keep what you have
on the given points.

451
00:33:34,440 --> 00:33:38,030
And I'm just going to
do linear interpolation.

452
00:33:38,030 --> 00:33:46,270
So halfway there, halfway
there, and halfway there.

453
00:33:46,270 --> 00:33:51,810
So I'm inputting-- ignoring the
boundary conditions, the zeros,

454
00:33:51,810 --> 00:33:59,410
I'm-- it's going to
be 5 by 2 I think,

455
00:33:59,410 --> 00:34:07,990
this matrix I in this example
will be 5 by 2 because it has 2

456
00:34:07,990 --> 00:34:11,320
inputs, these, and
it has 5 outputs.

457
00:34:11,320 --> 00:34:12,660
And what's the matrix?

458
00:34:16,590 --> 00:34:21,050
Well, for the second
and fourth outputs

459
00:34:21,050 --> 00:34:32,300
it uses exactly--
this multiplies x,

460
00:34:32,300 --> 00:34:38,750
or I should say u, u_1 and u_2.

461
00:34:38,750 --> 00:34:45,010
Let me see if I'm-- if I'll
follow the notes in-- the notes

462
00:34:45,010 --> 00:34:55,520
use v_1 and v_2 for the coarse
mesh values to avoid h, 2h,

463
00:34:55,520 --> 00:34:56,850
extra subscripts.

464
00:34:56,850 --> 00:35:00,560
So this height is v_1,
this height is v_2,

465
00:35:00,560 --> 00:35:07,910
and I'm going to take-- this'll
be the new u_1, u_3, and u_5.

466
00:35:07,910 --> 00:35:10,850
And u_2 I'm going to save.

467
00:35:14,600 --> 00:35:20,260
I better put I and make this
into a true equation, I*v.

468
00:35:20,260 --> 00:35:26,200
This is going to give me the
values u_1, u_2, u_3, u_4,

469
00:35:26,200 --> 00:35:29,500
and u_5.

470
00:35:29,500 --> 00:35:34,720
So u_2 is just v_1.

471
00:35:34,720 --> 00:35:39,010
u_4 is just v_2.

472
00:35:39,010 --> 00:35:41,050
No problem.

473
00:35:41,050 --> 00:35:43,381
And what do I do
with the other ones?

474
00:35:43,381 --> 00:35:43,880
Let's see.

475
00:35:43,880 --> 00:35:53,150
I guess u_1 is halfway
between v_1 and 0.

476
00:35:53,150 --> 00:35:54,840
OK, so it's 1/2.

477
00:35:58,280 --> 00:36:04,490
u_1 is just 1/2 v_1,
it doesn't involve v_2.

478
00:36:04,490 --> 00:36:09,010
u_3, which is sitting
here is half of these,

479
00:36:09,010 --> 00:36:14,510
so it's half of this and half
of that where this was nothing.

480
00:36:14,510 --> 00:36:19,630
Then u_4 was the same
as v_2, just take v_2.

481
00:36:19,630 --> 00:36:20,940
And what's u_5?

482
00:36:20,940 --> 00:36:23,980
u_5 is half of v_2
and half of zero.

483
00:36:29,200 --> 00:36:36,110
So it's a simple matrix,
the interpolation matrix.

484
00:36:36,110 --> 00:36:38,670
It's just reasonable
to use the letter I

485
00:36:38,670 --> 00:36:42,670
and we all recognize, here
it's a rectangular matrix, not

486
00:36:42,670 --> 00:36:44,280
the identity.

487
00:36:44,280 --> 00:36:45,970
I doesn't stand
for identity here,

488
00:36:45,970 --> 00:36:48,500
it stands for interpolation.

489
00:36:48,500 --> 00:36:52,340
OK, so I hope you can
focus on the matrix.

490
00:36:57,650 --> 00:37:02,510
And if it was much, much
bigger, but still in 1D,

491
00:37:02,510 --> 00:37:04,210
it wouldn't look very different.

492
00:37:04,210 --> 00:37:07,420
Each column would
have a 1/2, 1, 1/2.

493
00:37:07,420 --> 00:37:12,010
That's a typical part of
the interpolation matrix.

494
00:37:12,010 --> 00:37:17,760
It uses the value v_1, saves
it at the center point,

495
00:37:17,760 --> 00:37:20,830
uses half of it at the
previous point, and half of it

496
00:37:20,830 --> 00:37:23,800
at the right-hand point.

497
00:37:23,800 --> 00:37:34,120
And similarly, you see it's sort
of a typical rectangular matrix

498
00:37:34,120 --> 00:37:36,560
in signal processing as well.

499
00:37:39,720 --> 00:37:43,410
I have to say something
about what happens in 2D

500
00:37:43,410 --> 00:37:47,500
because our problems are in 2D.

501
00:37:47,500 --> 00:37:52,520
Maybe I just draw
a typical 2D mesh.

502
00:37:55,940 --> 00:38:00,160
These are the coarse values,
this is the coarse mesh and now

503
00:38:00,160 --> 00:38:03,270
I'll-- and of course,
we'll save those values.

504
00:38:03,270 --> 00:38:07,040
I will have a 1, so
it'll save those values

505
00:38:07,040 --> 00:38:13,670
when it goes to the fine mesh,
the fine mesh being half.

506
00:38:13,670 --> 00:38:16,530
So I just have to
decide what to do there.

507
00:38:16,530 --> 00:38:18,160
So question mark.

508
00:38:18,160 --> 00:38:21,350
What value shall I
take-- oh, I suppose

509
00:38:21,350 --> 00:38:23,520
I have to decide there, too.

510
00:38:23,520 --> 00:38:28,890
These are all new points
and what shall I do.

511
00:38:28,890 --> 00:38:31,400
I'm just going to stay with
linear interpolation, which

512
00:38:31,400 --> 00:38:34,250
is quite fast and satisfactory.

513
00:38:34,250 --> 00:38:37,650
This value will be the
average of those two.

514
00:38:37,650 --> 00:38:39,754
This value will be
the average of those

515
00:38:39,754 --> 00:38:41,420
and what will this
one be in the center?

516
00:38:41,420 --> 00:38:49,060
It's the average of
these four, of course.

517
00:38:49,060 --> 00:38:50,490
And that's what we'll get.

518
00:38:50,490 --> 00:38:56,910
Actually, that Kronecker product
business, a Kronecker product

519
00:38:56,910 --> 00:39:01,350
of a 1D matrix like
that with itself

520
00:39:01,350 --> 00:39:05,590
would be a 2D interpolation
that would do exactly this.

521
00:39:05,590 --> 00:39:08,260
We can write it out
more fully, but it's not

522
00:39:08,260 --> 00:39:13,630
fun to write out really fully
because if this is 5 by 2,

523
00:39:13,630 --> 00:39:17,970
then I2D would be 25 by 4.

524
00:39:20,970 --> 00:39:24,700
So we're right away, even
on this tiny, tiny problem,

525
00:39:24,700 --> 00:39:28,510
we're right away up
to 25 internal mesh

526
00:39:28,510 --> 00:39:29,680
points on the fine mesh.

527
00:39:32,850 --> 00:39:34,920
That's the matrix that
I want you to see.

528
00:39:34,920 --> 00:39:43,760
And, the natural choice
for R is the transpose.

529
00:39:46,450 --> 00:39:50,890
So one possible choice-- and it
will, the answer will be yes,

530
00:39:50,890 --> 00:39:52,540
we do use neighbors.

531
00:39:52,540 --> 00:40:00,530
So R will be the
transpose of I. Actually,

532
00:40:00,530 --> 00:40:03,620
I'll need a factor here.

533
00:40:03,620 --> 00:40:06,740
I think it's 1/2.

534
00:40:06,740 --> 00:40:09,390
Let me just see what it is.

535
00:40:09,390 --> 00:40:18,180
Let me see why we need a little
multiple there to make things

536
00:40:18,180 --> 00:40:20,310
right.

537
00:40:20,310 --> 00:40:23,170
So there's my matrix
I, so I'm just

538
00:40:23,170 --> 00:40:31,310
going to transpose it and
let me factor 1/2 out of that

539
00:40:31,310 --> 00:40:34,760
so you see these matrices
without fractions inside.

540
00:40:34,760 --> 00:40:37,280
That would be 1, 2, 1.

541
00:40:37,280 --> 00:40:38,640
So I'm going to transpose that.

542
00:40:38,640 --> 00:40:41,340
1, 2, 1, 0, 0.

543
00:40:41,340 --> 00:40:43,210
0, 0, 1, 2, 1.

544
00:40:45,800 --> 00:40:49,550
So I factored 1/2 out
of I when I did that.

545
00:40:49,550 --> 00:40:52,060
And then I believe that
I need another 1/2 here.

546
00:40:52,060 --> 00:40:54,410
I think I need 1/4.

547
00:40:54,410 --> 00:40:56,660
And what do I mean
by needing 1/4?

548
00:41:02,010 --> 00:41:04,810
Of course, the main
point is that this

549
00:41:04,810 --> 00:41:07,330
is the transpose of this.

550
00:41:07,330 --> 00:41:12,310
And you'll see that that
preserves the symmetry.

551
00:41:12,310 --> 00:41:17,910
That's just sort of the
natural thing to pick.

552
00:41:17,910 --> 00:41:20,580
Not the only possibility,
but it's very good

553
00:41:20,580 --> 00:41:25,190
to connect the restriction
with the interpolation.

554
00:41:25,190 --> 00:41:28,790
Of course, you can't
take the restriction

555
00:41:28,790 --> 00:41:31,140
to be the inverse of
the interpolation.

556
00:41:31,140 --> 00:41:32,970
Why not?

557
00:41:32,970 --> 00:41:39,990
I mean that sort of mental idea
is that the restriction goes

558
00:41:39,990 --> 00:41:41,970
in one direction and
the interpolation

559
00:41:41,970 --> 00:41:43,010
in the other direction.

560
00:41:43,010 --> 00:41:45,800
So why not just let one be
the inverse of the other?

561
00:41:45,800 --> 00:41:50,100
Well of course, that matrix
doesn't have an inverse.

562
00:41:54,680 --> 00:41:57,540
I mean its rank is only 2.

563
00:41:57,540 --> 00:42:01,450
When we do a restriction we're
going to lose information,

564
00:42:01,450 --> 00:42:04,080
the interpolation
can't put it all back

565
00:42:04,080 --> 00:42:10,430
because we threw it away when we
restricted to the coarse mesh.

566
00:42:10,430 --> 00:42:12,030
Now why 1/4?

567
00:42:12,030 --> 00:42:17,970
I think it's just if we had
all constants, like all ones,

568
00:42:17,970 --> 00:42:22,280
as our mesh values,
we would want

569
00:42:22,280 --> 00:42:26,910
to get all ones for
the restriction.

570
00:42:26,910 --> 00:42:31,890
So if I multiply this matrix
by the vector of all ones--

571
00:42:31,890 --> 00:42:37,670
so assuming you remember
where R comes in,

572
00:42:37,670 --> 00:42:43,540
if I just copy
this equation, you

573
00:42:43,540 --> 00:42:51,170
remember that I go from the
h mesh, it's fine to coarse.

574
00:42:55,770 --> 00:43:09,110
So R times ones on the fine
mesh, all ones on the fine mesh

575
00:43:09,110 --> 00:43:13,410
gives ones on the coarse mesh.

576
00:43:13,410 --> 00:43:20,980
That's why I wanted that-- you
see, if I multiply by all ones

577
00:43:20,980 --> 00:43:25,080
then that multiplication gives
me 1 plus 2 plus 1 equal 4

578
00:43:25,080 --> 00:43:30,550
and I need to divide by
4 to get back to the 1.

579
00:43:30,550 --> 00:43:35,550
You quickly discover
that that just arises

580
00:43:35,550 --> 00:43:37,760
because of a change of scale.

581
00:43:37,760 --> 00:43:40,200
It's just a factor of 1/2.

582
00:43:40,200 --> 00:43:45,730
In 2D that 1/2 there
would change to 1/4.

583
00:43:45,730 --> 00:43:48,740
In 3D it'd be 1/8.

584
00:43:48,740 --> 00:43:54,550
It's just the scaling
to preserve constants.

585
00:43:57,880 --> 00:44:01,650
And now the remaining
question is, what's A_(2h).

586
00:44:01,650 --> 00:44:08,810
That's the other matrix
here that we're not given.

587
00:44:08,810 --> 00:44:13,030
We're given the
A_h, our problem.

588
00:44:13,030 --> 00:44:17,240
We choose an R and we choose
an I and if we're smart,

589
00:44:17,240 --> 00:44:19,620
one's the transpose
of the other.

590
00:44:19,620 --> 00:44:21,920
And then the question
is, what's A_(2h)?

591
00:44:21,920 --> 00:44:27,680
And there's a beautiful answer,
so let me just say what it is.

592
00:44:27,680 --> 00:44:46,240
A_(2h), the coarse mesh matrix,
is the fine mesh matrix,

593
00:44:46,240 --> 00:44:57,330
but I need to do first-- if this
is going to apply to the coarse

594
00:44:57,330 --> 00:45:03,660
mesh guys, the v's, I have
to do an interpolation.

595
00:45:06,539 --> 00:45:07,330
You'll see it here.

596
00:45:07,330 --> 00:45:12,710
This is 5 by 5 in my problem.

597
00:45:12,710 --> 00:45:17,510
So I need to first
do the interpolation

598
00:45:17,510 --> 00:45:22,670
to get from a vector of length
2 up to a vector of length 5.

599
00:45:22,670 --> 00:45:25,330
Then this and then
the restriction.

600
00:45:25,330 --> 00:45:26,770
That's terrific.

601
00:45:26,770 --> 00:45:27,520
That's A_(2h).

602
00:45:32,900 --> 00:45:40,550
So this is A_(2h) and
we'd better do an example.

603
00:45:40,550 --> 00:45:42,090
I guess it's going
to be next time.

604
00:45:42,090 --> 00:45:46,160
So that'll be the first thing
for next time, would be to see,

605
00:45:46,160 --> 00:45:50,690
okay, for the standard
second difference A_h,

606
00:45:50,690 --> 00:45:55,630
for these piecewise linear
interpolation and restriction,

607
00:45:55,630 --> 00:45:59,380
what comes out as A_(2h)?

608
00:45:59,380 --> 00:46:03,760
Do we get the standard
second difference

609
00:46:03,760 --> 00:46:10,640
on the coarse mesh, which you
really hope we do and we do.

610
00:46:10,640 --> 00:46:15,300
This will be the second
difference, in our example,

611
00:46:15,300 --> 00:46:16,810
on the coarse mesh.

612
00:46:21,130 --> 00:46:26,390
So that this middle step of
multigrid is exactly what

613
00:46:26,390 --> 00:46:29,630
we would have expected.

614
00:46:29,630 --> 00:46:32,330
What we would've had if we
set up the problem originally

615
00:46:32,330 --> 00:46:33,940
on the coarse mesh.

616
00:46:33,940 --> 00:46:37,260
But now we're going to get
an answer that we take back

617
00:46:37,260 --> 00:46:38,560
to the fine mesh.

618
00:46:38,560 --> 00:46:41,260
OK, so I'll do that next time.

619
00:46:41,260 --> 00:46:45,990
Some homeworks here that I
held for an extra two days

620
00:46:45,990 --> 00:46:50,780
and now I'm returning and
some thoughts to go up

621
00:46:50,780 --> 00:46:54,340
on to the website about
possible projects,

622
00:46:54,340 --> 00:46:57,210
but actually, I
expressed a lot of them

623
00:46:57,210 --> 00:46:59,280
at the beginning of the lecture.

624
00:46:59,280 --> 00:47:00,510
OK, thanks.

625
00:47:00,510 --> 00:47:01,760
Good.